# The master WEST configuration file for a simulation.
# Specific documentation is included near applicable entries, but a few general
# words are in order.
# 
# This file is parsed using the Python ConfigParser module, so variables can be
# defined within each section and then referenced using ConfigParser %(...)s
# formatting, as in::
#
#    some_master_path = /home/nph/west
#    a_relative_path = %(some_master_path)s/subdir
#
# Further, most entries are subject to environment variable expansion using
# os.path.expandvars()::
#
#    west_root = $HOME/west
#
# All pathname entries are subject to both the environment variable expansion
# above, and also to home directory expansion with os.path.expanduser()::
#
#    segment_data_ref = ~/westsim/traj_segs

[drivers]
propagator   = executable
#work_manager = zmq

[limits]
max_iterations = 100
max_wallclock  = 3:00:00

[data]
load_auxdata = True
west_data_file = west.h5

[system]
# The system module is almost always loaded from outside the typical locations
# (those named in ``sys.path``, including $PYTHONPATH), so we explicitly
# include $WEST_SIM_ROOT. Technically, this isn't necessary, as if it's unset
# it will be set to the current directory when invoking WEST tools, but it's
# usually better to be explicit.
module_path   = $WEST_SIM_ROOT

# The system driver is a class specified by the user and including data such as
# progress coordinate dimensionality and bin boundaries.  Because the system
# driver is available in all WEST processes, it is also an ideal place to put
# custom processing routines. (However, different processes do not share the
# same system instance, so don't rely on shared state.)
system_driver = system.System

# If gen_istates is true, then initial states of new trajectories are generated
# from basis states. Otherwise, basis states are used directly as initial
# states for new trajectories.
gen_istates = True


[executable]

# The executable propagator delegates propagation of dynamics segments to an
# executable (usually a shell script) which is responsible for setting up and
# propagating an individual segment. A small amount of data is passed from the
# WEST code to the propagator executable through environment variables, which
# are configured in this section.  These environment variables are assumed to
# be pathnames, and home directory and environment variable references will be
# expanded accordingly [using os.path.expanduser() and os.path.expandvars(),
# respectively]. In addition, executables called for individual segments
# (such as the propagator) have variables expanded using Python 2.7/3.x
# string formatting, with ``segment`` and ``parent`` named variables
# available; this is what permits putting different segments in different
# directories, as in relative/path/to/segments/{segment.n_iter}/{segment.seg_id}.
# (See below for futher examples).

# Because this configuration file is parsed with the Python ConfigParser module,
# internal substitution is possible using %(...)s formatting.  This permits us
# to define a location to store a segment and then reference it elsewhere.
# It is recommended that these internal substitutions be in all caps, to 
# clearly distinguish them from WEST configuration items.
ITERATION_DIR = $WEST_SIM_ROOT/traj_segs/{n_iter:06d}
SEGMENT_DIR = $WEST_SIM_ROOT/traj_segs/{segment.n_iter:06d}/{segment.seg_id:06d}
PARENT_DIR  = $WEST_SIM_ROOT/traj_segs/{parent.n_iter:06d}/{parent.seg_id:06d}

# segment_data_ref refers to where per-segment information data is expected to
# be found.  Similarly, parent_data_ref refers to where a segment's parent is
# to be found.  These are typically filesystem paths representing directories
# where individual dynamics segments are stored.  Both are expanded with
# str.format() with the following fields: segment (current segment, all
# applicable fields populated); parent (parent segment, only n_iter and seg_id
# are populated). Following the expansion with str.format(), environment
# variables and home directories are expanded (using os.path.expandvars() and
# .expanduser(), respectively).
segment_data_ref = %(SEGMENT_DIR)s
parent_data_ref  = %(PARENT_DIR)s

basis_state_data_ref   = $WEST_SIM_ROOT/bstates/{basis_state.auxref}
initial_state_data_ref = $WEST_SIM_ROOT/istates/{initial_state.iter_created}/{initial_state.state_id}.gro


# The ``get_pcoord`` executable is responsible for calculating progress
# coordinate data for point structures (as opposed to trajectories).
get_pcoord = $WEST_SIM_ROOT/get_pcoord.sh
get_pcoord.stdout = /dev/null
get_pcoord.stderr = stdout

# The ``gen_istate`` executable, if defined, is responsible for creating a new
# simulation's initial state from a basis state. If a ``gen_istate`` executable
# is not defined here, then a basis state is used directly.
gen_istate = $WEST_SIM_ROOT/gen_istate.sh
#gen_istate.stdout = $WEST_SIM_ROOT/seg_logs/gen_istate-{initial_state.iter_created:06d}-{initial_state.state_id:06d}.log
gen_istate.stdout = /dev/null
gen_istate.stderr = stdout



# The propagator is responsible for setting up and propagating an individual
# segment. The propagator must be specified for every WEST simulation.
propagator = $WEST_SIM_ROOT/runseg.sh

# Output redirections are possible. Using the special name ``stdout`` for 
# standard error redirection will merge the standard error stream into the
# standard output stream. (There is no corresponding special name to merge
# standard output into standard error, since it would have the same effect
# as specifying a standard output file and stderr=stdout.)
# By default, no redirection is performed (which is *very* messy)
propagator.stdout = $WEST_SIM_ROOT/seg_logs/{segment.n_iter:06d}-{segment.seg_id:06d}.log
#propagator.stderr = $WEST_SIM_ROOT/seg_logs/{segment.n_iter:06d}-{segment.seg_id:06d}.err
propagator.stderr = stdout
#propagator.stdout = /dev/null
#propagator.stderr = /dev/null

# Standard input may also be redirected; by default, input is redirected
# from /dev/null.  This is probably a corner-case feature for the rare situations
# in which dynamics code can be called directly from WEST, instead of the more
# common case where a shell script must be written to properly construct input
# before propagating dynamics.  But, it's here if it's needed.
#propagator.stdin = %(SEGMENT_DIR)s/sim.inp

# The working directory of the propagator may also be specified.
#propagator.cwd = %(SEGMENT_DIR)s

# Additional environment variables may be specified
#propagator.env.SEG_DEBUG=0
propagator.env.SEG_DEBUG=1

# Pre-iteration and post-iteration processing is possible using ``pre_iteration``
# and ``post_iteration`` executables, respectively. The same redirections
# above are possible here. Note that the only value available for string
# interpolation is ``n_iter``, the iteration number about to commence
# (for pre_iteration) or just finished (for post_iteration).
#post_iteration = $WEST_SIM_ROOT/post_iter.sh
#post_iteration.stdout = %(ITERATION_DIR)s
#post_iteration.stderr = stdout


# Data (including progress coordinate data) is returned to the WEST code by
# reading files written by the propagator executable. In addition to progress
# coordinate data, arbitrary data may be returned, which will be stored in the
# HDF5 file. These data files are specified with ``data.DATASET.filename``,
# where DATASET is how the data will be named in the HDF5 file. Progress
# coordinate data is ``pcoord`` (leading to ``data.pcoord.filename``).
# By default, these are temporary files, created prior to propagator
# execution and deleted after they are read. For persistent files, specify
# a filename here.

#data.pcoord.filename = %(SEGMENT_DIR)s/pcoord.txt

# By default, these data files are text files containing numeric data and are
# read with ``numpy.loadtxt()``. A custom processing routine may be specified
# with ``data.DATASET.loader``. The system module is an ideal place for such
# things, as it is automatically available in all worker processes.

#data.pcoord.loader = system.pcoord_loader

# Arbitrary auxiliary data can be stored as well.
data.coord.enabled = True
data.coord.loader  = system.coord_loader


